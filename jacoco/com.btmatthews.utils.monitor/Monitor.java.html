<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Monitor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Monitor Thread</a> &gt; <a href="index.source.html" class="el_package">com.btmatthews.utils.monitor</a> &gt; <span class="el_source">Monitor.java</span></div><h1>Monitor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2011-2021 Brian Matthews
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.btmatthews.utils.monitor;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.net.BindException;
import java.net.ConnectException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * The monitor object is used to control a server.
 *
 * @author &lt;a href=&quot;mailto:brian@btmatthews.com&quot;&gt;Brian Matthews&lt;/a&gt;
 * @since 1.0.0
 */
public final class Monitor {

    /**
     * The regex for the configure command.
     */
<span class="fc" id="L48">    private static final Pattern CONFIGURE_PATTERN = Pattern.compile(&quot;configure\\s+(\\w+)=(.*)&quot;);</span>
    /**
     * The default number of times to retry when checking for successful server start
     * or stop.
     *
     * @since 2.1.0
     */
    private static final int DEFAULT_RETRY_COUNT = 3;
    /**
     * The default interval between retries when checking for successful server start
     * or stop.
     *
     * @since 2.1.0
     */
    private static final int DEFAULT_RETRY_INTERVAL = 500;
    /**
     * The stop command.
     */
    private static final String STOP = &quot;stop&quot;;
    /**
     * The monitor key that must prefix any commands.
     */
    private final String monitorKey;
    /**
     * The port on which the monitor is listening.
     */
    private final int monitorPort;
    /**
     * The number of times to retry when checking for successful server start
     * or stop.
     *
     * @since 2.1.0
     */
    private final int retryCount;
    /**
     * The interval between retries when checking for successful server start
     * or stop.
     *
     * @since 2.1.0
     */
    private final int retryInterval;

    /**
     * The constructor that initialises the monitor key and port.
     *
     * @param key  The monitor key that must prefix any commands.
     * @param port The port on which the monitor is listening.
     */
    public Monitor(final String key, final int port) {
<span class="fc" id="L97">        this(key, port, DEFAULT_RETRY_COUNT, DEFAULT_RETRY_INTERVAL);</span>
<span class="fc" id="L98">    }</span>

    /**
     * The constructor that initialises the monitor key and port.
     *
     * @param key      The monitor key that must prefix any commands.
     * @param port     The port on which the monitor is listening.
     * @param count    The number of retry counts.
     * @param interval The intervals between retries.
     */
<span class="fc" id="L108">    public Monitor(final String key, final int port, final int count, final int interval) {</span>
<span class="fc" id="L109">        monitorKey = key;</span>
<span class="fc" id="L110">        monitorPort = port;</span>
<span class="fc" id="L111">        retryCount = count;</span>
<span class="fc" id="L112">        retryInterval = interval;</span>
<span class="fc" id="L113">    }</span>

    /**
     * Static method used to send a command to a server via a monitor.
     *
     * @param key     The monitor key.
     * @param port    The monitor port.
     * @param command The command to be sent to the server.
     * @param logger  Used to log information and error messages.
     */
    public static void sendCommand(final String key, final int port, final String command, final Logger logger) {
<span class="fc" id="L124">        new Monitor(key, port).sendCommand(command, logger);</span>
<span class="fc" id="L125">    }</span>

    /**
     * Run the monitor listening for commands and sending them to the server.
     *
     * @param server   The server being monitored.
     * @param logger   Used to log error messages.
     * @param observer Used to handle notifications for server start and stop.
     */
    public void runMonitor(final Server server, final Logger logger, final MonitorObserver observer) {
<span class="fc" id="L135">        try (final ServerSocket serverSocket = bindMonitor()) {</span>
<span class="fc" id="L136">            server.start(logger);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (waitForStart(server, logger)) {</span>
<span class="fc" id="L138">                observer.started(server, logger);</span>
<span class="fc" id="L139">                runMonitorInternal(server, logger, serverSocket);</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">                if (waitForStop(server, logger)) {</span>
<span class="fc" id="L141">                    observer.stopped(server, logger);</span>
                }
            }
<span class="fc" id="L144">        } catch (final IOException exception) {</span>
<span class="fc" id="L145">            logger.logError(&quot;Error starting or stopping the monitor&quot;, exception);</span>
<span class="fc" id="L146">        }</span>
<span class="fc" id="L147">    }</span>

    /**
     * Spawn a thread used to run the monitor as daemon processes.
     *
     * @param server   The server.
     * @param logger   Used to log information and error messages.
     * @param observer Used to handle notifications for server start and stop.
     * @return The thread that was spawned to run the monitor.
     */
    public Thread runMonitorDaemon(final Server server, final Logger logger, final MonitorObserver observer) {
<span class="fc" id="L158">        final Thread monitorThread = new Thread(() -&gt; Monitor.this.runMonitor(server, logger, observer));</span>
<span class="fc" id="L159">        monitorThread.setDaemon(true);</span>
<span class="fc" id="L160">        monitorThread.start();</span>
<span class="fc" id="L161">        waitForStart(server, logger);</span>
<span class="fc" id="L162">        return monitorThread;</span>
    }

    /**
     * Run the monitor listening for commands at {@code serverSocket} and sending them to the server.
     *
     * @param server       The server being monitored.
     * @param logger       Used to log error messages.
     * @param serverSocket The server socket on which the monitor is listening.
     */
    private void runMonitorInternal(final Server server, final Logger logger, final ServerSocket serverSocket) {
<span class="fc" id="L173">        boolean running = true;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        while (running) {</span>
<span class="fc" id="L175">            Socket clientSocket = null;</span>
            try {
                try {
<span class="fc" id="L178">                    logger.logInfo(&quot;Waiting for command from client&quot;);</span>
<span class="fc" id="L179">                    clientSocket = serverSocket.accept();</span>
<span class="fc" id="L180">                    logger.logInfo(&quot;Receiving command from client&quot;);</span>
<span class="fc" id="L181">                    clientSocket.setSoLinger(false, 0);</span>
<span class="fc" id="L182">                    final String command = getCommand(clientSocket, logger);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                    if (command != null) {</span>
<span class="fc" id="L184">                        running = executeCommand(server, command, logger);</span>
                    }
                } finally {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                    if (clientSocket != null) {</span>
<span class="fc" id="L188">                        clientSocket.close();</span>
                    }
                }
<span class="nc" id="L191">            } catch (final IOException exception) {</span>
<span class="nc" id="L192">                logger.logError(&quot;Error in the monitor&quot;, exception);</span>
<span class="fc" id="L193">            }</span>
<span class="fc" id="L194">        }</span>
<span class="fc" id="L195">    }</span>

    /**
     * Read the key and command combination from the client socket connection.
     *
     * @param clientSocket The client socket connection.
     * @param logger       Used to log error messages.
     * @return The command that was read from the client socket connection or {@code null} if the key did not match.
     * @throws IOException If there was an error reading from the client socket connection.
     */
    private String getCommand(final Socket clientSocket, final Logger logger) throws IOException {
<span class="fc" id="L206">        final InputStream inputStream = clientSocket.getInputStream();</span>
<span class="fc" id="L207">        final Reader reader = new InputStreamReader(inputStream);</span>
<span class="fc" id="L208">        final LineNumberReader lineReader = new LineNumberReader(reader);</span>
<span class="fc" id="L209">        final String key = lineReader.readLine();</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (monitorKey.equals(key)) {</span>
<span class="fc" id="L211">            return lineReader.readLine();</span>
        } else {
<span class="fc" id="L213">            logger.logError(&quot;Invalid monitor key&quot;);</span>
<span class="fc" id="L214">            return null;</span>
        }
    }

    /**
     * Send a command to the monitor.
     *
     * @param command The command.
     * @param logger  Used to log error messages.
     */
    public void sendCommand(final String command, final Logger logger) {
<span class="fc" id="L225">        logger.logInfo(&quot;Sending command \&quot;&quot; + command + &quot;\&quot; to monitor&quot;);</span>
<span class="fc" id="L226">        try (final Socket socket = connectMonitor()) {</span>
<span class="fc" id="L227">            socket.setSoLinger(false, 0);</span>
<span class="fc" id="L228">            final OutputStream outputStream = socket.getOutputStream();</span>
<span class="fc" id="L229">            final Writer writer = new OutputStreamWriter(outputStream);</span>
<span class="fc" id="L230">            final PrintWriter printWriter = new PrintWriter(writer);</span>
<span class="fc" id="L231">            printWriter.println(monitorKey);</span>
<span class="fc" id="L232">            printWriter.println(command);</span>
<span class="fc" id="L233">            printWriter.flush();</span>
<span class="fc" id="L234">        } catch (final IOException exception) {</span>
<span class="fc" id="L235">            logger.logError(&quot;Error sending command to monitor&quot;, exception);</span>
<span class="fc" id="L236">        }</span>
<span class="fc" id="L237">    }</span>

    /**
     * Execute a command that was sent to the monitor.
     * &lt;p/&gt;
     * The following commands are supported:
     * &lt;ul&gt;
     * &lt;li&gt;configure name=value - Set the server property {@code name} to {@code value}&lt;/li&gt;
     * &lt;li&gt;stop - Stop the server&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param server  The server.
     * @param command The command.
     * @param logger  Used to log error messages.
     * @return Indicates whether or not the monitor is should continue running.
     * &lt;ul&gt;
     * &lt;li&gt;{@code true} if the monitor should continue running&lt;/li&gt;
     * &lt;li&gt;{@code false} if the monitor should stop&lt;/li&gt;
     * &lt;/ul&gt;
     */
    private boolean executeCommand(final Server server, final String command,
                                   final Logger logger) {
<span class="fc" id="L259">        final Matcher matcher = CONFIGURE_PATTERN.matcher(command);</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (matcher.matches()) {</span>
<span class="fc" id="L261">            server.configure(matcher.group(1), matcher.group(2), logger);</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        } else if (STOP.equals(command)) {</span>
<span class="fc" id="L263">            server.stop(logger);</span>
<span class="fc" id="L264">            return false;</span>
        }
<span class="fc" id="L266">        return true;</span>
    }

    /**
     * Wait for the server to start.
     *
     * @param server The server being monitored.
     * @param logger Used to log error messages.
     * @return {@code true} if the server has started.
     * @since 2.1.0
     */
    private boolean waitForStart(final Server server, final Logger logger) {
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (server.isStarted(logger)) {</span>
<span class="fc" id="L279">            return true;</span>
        }
        try {
<span class="nc" id="L282">            Thread.sleep(retryInterval);</span>
<span class="nc" id="L283">        } catch (final InterruptedException e) {</span>
<span class="nc" id="L284">            return false;</span>
<span class="nc" id="L285">        }</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        for (int i = 1; i &lt; retryCount; ++i) {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if (server.isStarted(logger)) {</span>
<span class="nc" id="L288">                return true;</span>
            }
        }
<span class="nc" id="L291">        return false;</span>
    }

    /**
     * Wait for the server to stop.
     *
     * @param server The server being monitored.
     * @param logger Used to log error messages.
     * @return {@code true} if the server has stopped.
     * @since 2.1.0
     */
    private boolean waitForStop(final Server server, final Logger logger) {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (server.isStopped(logger)) {</span>
<span class="fc" id="L304">            return true;</span>
        }
<span class="nc bnc" id="L306" title="All 2 branches missed.">        for (int i = 1; i &lt; retryCount; ++i) {</span>
            try {
<span class="nc" id="L308">                Thread.sleep(retryInterval);</span>
<span class="nc" id="L309">            } catch (final InterruptedException e) {</span>
<span class="nc" id="L310">                return false;</span>
<span class="nc" id="L311">            }</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (server.isStopped(logger)) {</span>
<span class="nc" id="L313">                return true;</span>
            }
        }
<span class="nc" id="L316">        return false;</span>
    }

    /**
     * Bind to the monitor first attempting to use {@link java.net.InetAddress#getLocalHost()} then falling
     * back to using the loopback address if there is a security exception.
     *
     * @return The bound server socket.
     * @throws IOException If there was a problem binding to the server socket.
     * @since 2.1.2
     */
    private ServerSocket bindMonitor() throws IOException {
<span class="fc" id="L328">        final ServerSocket serverSocket = new ServerSocket();</span>
<span class="fc" id="L329">        serverSocket.setReuseAddress(true);</span>
        try {
<span class="fc" id="L331">            serverSocket.bind(new InetSocketAddress(InetAddress.getLocalHost(), monitorPort), 1);</span>
<span class="fc" id="L332">        } catch (final BindException e) {</span>
<span class="nc" id="L333">            serverSocket.bind(new InetSocketAddress(&quot;localhost&quot;, monitorPort), 1);</span>
<span class="fc" id="L334">        }</span>
<span class="fc" id="L335">        return serverSocket;</span>
    }

    /**
     * Connect to the monitor first attempting to use {@link java.net.InetAddress#getLocalHost()} then falling
     * back to using the loopback address if there is a security exception.
     *
     * @return The connected  socket.
     * @throws IOException If there was a problem connecting to the socket.
     * @since 2.1.2
     */
    private Socket connectMonitor() throws IOException {
        try {
<span class="fc" id="L348">            return new Socket(InetAddress.getLocalHost(), monitorPort);</span>
<span class="fc" id="L349">        } catch (final ConnectException e) {</span>
<span class="nc" id="L350">            return new Socket(&quot;localhost&quot;, monitorPort);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>